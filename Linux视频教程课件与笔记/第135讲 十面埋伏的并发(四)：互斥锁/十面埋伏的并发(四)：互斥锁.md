## 十面埋伏的并发(四)：互斥锁

#### 信号量与互斥锁：同步还是独占？

##### 信号量

- 强调信号机制(同步)
- 生产者--消费者模型
- 获取信号量失败，触发上下文调度

##### 互斥锁

- 强调互斥机制
- 独占共享资源

- 获取互斥锁失败，触发上下文调度

```
服务于多个线程间的执行的逻辑顺序的选信号量
服务于共享资源的选互斥锁
```

#### 自旋锁与互斥锁：休眠还是“忙等待”？

##### 自旋锁

- 加锁成本低，不释放cpu使用权

##### 互斥锁

- 加锁成本更高(上下文切换耗时在几十纳秒到几微秒之间)，加锁失败时会释放 CPU 给其他线程

```
无法判断锁住的代码会执行多久时，首选互斥锁
确定被锁住的代码执行时间很短，使用自旋锁取代互斥锁
```

#### 互斥锁相关API

##### 定义互斥锁

```
struct mutex lock;
```

##### 初始化互斥锁

```
void mutex_init(mutex *lock);
```

参数：

- lock：指定要初始化的互斥锁

##### 互斥锁加锁

```
void mutex_lock(struct mutex *lock);
```

参数：

- lock：指定要加锁的互斥锁

##### 尝试获取互斥锁

```
int mutex_trylock(struct mutex *lock);
```

尝试获取一次互斥锁，获取成功返回“true”,获取失败返回“false”。程序继续往下执行

##### 互斥锁解锁

```
void mutex_unlock(struct mutex *lock);
```

参数：

- lock：指定要解锁的互斥锁

